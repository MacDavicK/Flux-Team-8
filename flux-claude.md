# Engineering Specification: AI-Powered Goal & Task Management App

> **Version:** 1.0 ‚Äî Greenfield  
> **Team:** 1 Frontend Engineer, 4 Backend Engineers  
> **Platform:** PWA (React) ‚Üí React Native (Phase 2)  
> **Stack:** Python FastAPI ¬∑ Supabase (PostgreSQL) ¬∑ LangGraph ¬∑ Twilio  
> **LLM Strategy:** Best-model-per-agent (specified per agent below)

---

## Table of Contents

1. [Product Vision](#1-product-vision)
2. [System Architecture Overview](#2-system-architecture-overview)
3. [Tech Stack ‚Äî Canonical Choices](#3-tech-stack--canonical-choices)
4. [Data Models](#4-data-models)
5. [Agent Architecture](#5-agent-architecture)
6. [LangGraph Orchestration](#6-langgraph-orchestration)
7. [Notification Engine](#7-notification-engine)
8. [Analytics & Dashboard](#8-analytics--dashboard)
9. [UI/UX Flows](#9-uiux-flows)
10. [Onboarding Flow](#10-onboarding-flow)
11. [API Design](#11-api-design)
12. [Privacy & Security Guardrails](#12-privacy--security-guardrails)
13. [Phase 2 Roadmap](#13-phase-2-roadmap)
14. [Open Decisions & Engineering Defaults](#14-open-decisions--engineering-defaults)

---

## 1. Product Vision

A conversational AI companion that turns vague human intentions ‚Äî "I want to lose weight," "I want to learn Spanish," "Remind me to buy groceries" ‚Äî into structured, sustainable, and achievable plans. The chat interface is the primary UX surface and core product differentiator. All task creation, modification, and rescheduling happens through conversation.

The system is built on two pillars:

**Goals** ‚Äî aspirations that require a multi-week plan broken into sustainable daily tasks. Backed by behavioral science: micro-goals designed to be achieved in ‚â§6 weeks, maintaining a >70% success rate. Each goal produces a pipeline of 6-week sprints that unlock sequentially upon completion.

**Tasks** ‚Äî discrete, time-bound (or location-triggered) reminders. A task may be standalone ("buy groceries when I leave home") or generated by a goal plan.

The app escalates notifications progressively (push ‚Üí WhatsApp ‚Üí phone call) to ensure follow-through, and uses behavioral pattern learning to optimize scheduling over time.

---

## 2. System Architecture Overview

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         PWA / React Native                      ‚îÇ
‚îÇ   Chat UI ¬∑ Home Screen (Today's Tasks) ¬∑ Analytics Dashboard   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ REST + WebSocket
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     FastAPI Backend                             ‚îÇ
‚îÇ  Auth ¬∑ Task CRUD ¬∑ Goal CRUD ¬∑ Analytics ¬∑ Notification Mgmt  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                                      ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   LangGraph Agent Graph  ‚îÇ      ‚îÇ        Supabase               ‚îÇ
‚îÇ                          ‚îÇ      ‚îÇ  PostgreSQL ¬∑ Auth ¬∑ Storage  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ      ‚îÇ  Realtime subscriptions       ‚îÇ
‚îÇ  ‚îÇ    Orchestrator     ‚îÇ ‚îÇ      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ         ‚îÇ                ‚îÇ      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ      ‚îÇ         Twilio                ‚îÇ
‚îÇ  ‚îÇ  Goal Planning      ‚îÇ ‚îÇ      ‚îÇ  WhatsApp Business API        ‚îÇ
‚îÇ  ‚îÇ  Agent              ‚îÇ ‚îÇ      ‚îÇ  Programmable Voice (calls)   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ         ‚îÇ                ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ‚îÇ  Sub-Agents (consulted by Goal Planner)        ‚îÇ
‚îÇ  ‚îÇ  ¬∑ Classifier  ¬∑ Scheduler  ¬∑ Pattern Observer ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ‚îÇ           Notifier Agent                       ‚îÇ
‚îÇ  ‚îÇ  (Background polling + Twilio dispatch)        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Key Architectural Decisions

- **LangGraph** manages all agent state machines, conditional routing, and multi-turn conversation context. Each user session maps to a LangGraph thread with persistent state via Supabase.
- **FastAPI** is the interface layer ‚Äî it exposes REST endpoints to the frontend and invokes LangGraph graphs.
- **Supabase** is used for PostgreSQL (data), Auth (JWT), Realtime (task status push to UI), and Storage (future: user avatars, voice memos).
- **The Notifier Agent** is a background worker (APScheduler or Celery beat) ‚Äî NOT part of the conversational graph. It polls task states and dispatches notifications.
- **Demo Mode** (MVP): location-based triggers are simulated via a frontend toggle ("I'm away from home"). No real GPS in MVP.

---

## 3. Tech Stack ‚Äî Canonical Choices

| Layer | Technology | Rationale |
|---|---|---|
| Frontend | React (PWA) ‚Üí React Native | PWA for fast iteration; RN for Phase 2 |
| Backend API | Python FastAPI | Native LangGraph support; async-first |
| Agent Framework | LangGraph (LangChain ecosystem) | Stateful graphs, conditional routing, thread memory |
| Database | Supabase (PostgreSQL) | Auth, Realtime, PostgREST, storage ‚Äî all-in-one |
| Background Jobs | APScheduler (MVP) ‚Üí Celery + Redis (scale) | Notification polling, micro-goal pipeline triggers |
| Notifications | Twilio (WhatsApp Business API + Voice) | Single vendor for all escalation channels |
| LLM ‚Äî Orchestrator | GPT-4o (OpenAI) | Strong intent classification + multi-turn reasoning |
| LLM ‚Äî Goal Planner | Claude 3.5 Sonnet (Anthropic) | Long-context planning, nuanced negotiation |
| LLM ‚Äî Classifier | GPT-4o-mini | Fast, cheap, structured output (JSON tags) |
| LLM ‚Äî Scheduler | GPT-4o-mini | Slot-finding logic with structured output |
| LLM ‚Äî Pattern Observer | GPT-4o-mini | Pattern summarization over historical data |
| LLM ‚Äî Notifier Agent | No LLM needed | Pure logic/state machine |
| Embeddings (future) | OpenAI text-embedding-3-small | Semantic task deduplication |

---

## 4. Data Models

All tables live in Supabase (PostgreSQL). Row Level Security (RLS) is enabled on all user-data tables.

### `users`
```sql
id              UUID PRIMARY KEY DEFAULT gen_random_uuid()
email           TEXT UNIQUE NOT NULL
created_at      TIMESTAMPTZ DEFAULT now()
onboarded       BOOLEAN DEFAULT false
profile         JSONB  -- stores onboarding answers (see ¬ß10)
notification_preferences JSONB
  -- {
  --   phone_number: string,
  --   whatsapp_opted_in: boolean,
  --   reminder_lead_minutes: int default 10,
  --   escalation_window_minutes: int default 2
  -- }
```

### `goals`
```sql
id              UUID PRIMARY KEY DEFAULT gen_random_uuid()
user_id         UUID REFERENCES users(id) ON DELETE CASCADE
title           TEXT NOT NULL
description     TEXT
class_tags      TEXT[]  -- ["Health", "Fitness"] from Classifier
status          TEXT CHECK (status IN ('active', 'completed', 'abandoned', 'pipeline'))
parent_goal_id  UUID REFERENCES goals(id)  -- for micro-goal chains
pipeline_order  INT  -- sequence within a micro-goal chain
created_at      TIMESTAMPTZ DEFAULT now()
activated_at    TIMESTAMPTZ
completed_at    TIMESTAMPTZ
target_weeks    INT DEFAULT 6
plan_json       JSONB  -- full plan as negotiated with user
```

### `tasks`
```sql
id              UUID PRIMARY KEY DEFAULT gen_random_uuid()
user_id         UUID REFERENCES users(id) ON DELETE CASCADE
goal_id         UUID REFERENCES goals(id)  -- NULL if standalone task
title           TEXT NOT NULL
description     TEXT
status          TEXT CHECK (status IN ('pending', 'done', 'missed', 'rescheduled', 'cancelled'))
scheduled_at    TIMESTAMPTZ
duration_minutes INT
trigger_type    TEXT CHECK (trigger_type IN ('time', 'location'))
location_trigger TEXT  -- e.g. "away_from_home" (MVP: simulated)
reminder_sent_at TIMESTAMPTZ
whatsapp_sent_at TIMESTAMPTZ
call_sent_at    TIMESTAMPTZ
completed_at    TIMESTAMPTZ
recurrence_rule TEXT  -- iCal RRULE string (e.g. "FREQ=DAILY;BYDAY=MO,WE,FR")
shared_with_goal_ids UUID[]  -- if task belongs to multiple goals
created_at      TIMESTAMPTZ DEFAULT now()
```

### `patterns`
```sql
id              UUID PRIMARY KEY DEFAULT gen_random_uuid()
user_id         UUID REFERENCES users(id) ON DELETE CASCADE
pattern_type    TEXT  -- 'time_avoidance', 'completion_streak', 'category_performance'
description     TEXT  -- human-readable: "User consistently misses Monday morning tasks"
data            JSONB  -- raw signal data
confidence      FLOAT  -- 0.0‚Äì1.0
created_at      TIMESTAMPTZ DEFAULT now()
updated_at      TIMESTAMPTZ DEFAULT now()
```

### `conversations`
```sql
id              UUID PRIMARY KEY DEFAULT gen_random_uuid()
user_id         UUID REFERENCES users(id)
langgraph_thread_id TEXT UNIQUE  -- ties to LangGraph thread state
context_type    TEXT CHECK (context_type IN ('onboarding', 'goal', 'task', 'reschedule'))
created_at      TIMESTAMPTZ DEFAULT now()
last_message_at TIMESTAMPTZ
```

### `notification_log`
```sql
id              UUID PRIMARY KEY DEFAULT gen_random_uuid()
task_id         UUID REFERENCES tasks(id)
channel         TEXT CHECK (channel IN ('push', 'whatsapp', 'call'))
sent_at         TIMESTAMPTZ
response        TEXT  -- 'done', 'reschedule', 'missed', 'no_response'
responded_at    TIMESTAMPTZ
```

---

## 5. Agent Architecture

There are **6 agents** in the system. Each is a node (or subgraph) in the LangGraph execution graph.

---

### 5.1 Orchestrator Agent

**Role:** The entry point for every user message. Routes to the correct downstream agent.

**LLM:** GPT-4o

**Responsibilities:**
- Determine if the input is a **goal** or a **task** (including rescheduled tasks).
- For tasks: determine if sufficient context exists (time, location), or if clarification is needed.
- For goals: hand off to the Goal Planning Agent.
- For reschedule requests (auto-typed from the notification CTA): extract the `task_id` from the message and route to the Scheduler for slot-finding.
- Maintain conversational context across multiple turns.

**Input:** Raw user message + conversation history + user profile (from DB)

**Output:** Routing decision + structured payload for downstream agent

**System Prompt:**
```
You are the Orchestrator for a personal goal and task management assistant.

Your job is to analyze the user's message and classify it into one of the following intents:
- GOAL: The user expresses an aspiration or multi-step desire (e.g., "I want to lose weight", "I want to learn guitar")
- NEW_TASK: The user wants a discrete, one-time or recurring reminder (e.g., "Remind me to buy groceries")
- RESCHEDULE_TASK: The user wants to reschedule an existing task. Message will contain a task_id.
- CLARIFY: You need more information before routing (e.g., a task with no time or location context)

Rules:
- If intent is NEW_TASK or RESCHEDULE_TASK, check if there is enough context: either a specific time, a recurrence pattern, or a location trigger.
- If context is missing, set intent to CLARIFY and specify exactly what is missing.
- Never guess. If ambiguous, ask one focused question.
- Always respond with valid JSON only:
  {
    "intent": "GOAL" | "NEW_TASK" | "RESCHEDULE_TASK" | "CLARIFY",
    "payload": { ... },
    "clarification_question": "string | null"
  }
```

---

### 5.2 Goal Planning Agent

**Role:** Converts a validated goal statement into a concrete, sustainable 6-week action plan through negotiation with the user.

**LLM:** Claude 3.5 Sonnet (best for long-context, nuanced multi-turn planning)

**Responsibilities:**
1. Assess if the goal is achievable in ‚â§6 weeks. If not, decompose into ordered micro-goals. Present the roadmap to the user for confirmation. Queue all but the first micro-goal in `goals` table with `status = 'pipeline'`.
2. Consult the **Classifier** for goal tags.
3. Consult the **Scheduler** for the user's available time slots over the next 6 weeks.
4. Consult the **Pattern Observer** for behavioral data.
5. Check if any generated tasks overlap with *existing active tasks* ‚Äî if so, flag them and present to the user ("I see you're already going to the gym on Tuesdays ‚Äî I'll incorporate that into your plan").
6. Generate a proposed plan (list of structured tasks with day/time/duration).
7. Negotiate with the user until confirmed. Allow slot negotiation.
8. On confirmation: write tasks to DB via the Scheduler. Notify user the plan is live.
9. If available slots are insufficient for 6 weeks: notify user that the goal will start on the first available date and set goal `status = 'pipeline'` with a future `activated_at`.

**Input:** Goal statement + user profile + Classifier output + Scheduler output + Pattern Observer output

**Output:** Confirmed task list (JSON) ‚Üí written to `tasks` table

**6-Week Rationale (surface to user):**
> "Based on behavioral science research, humans maintain a >70% success rate when goals are structured as focused 6-week sprints. Your plan is designed around this principle."

**System Prompt:**
```
You are a world-class personal coach and behavioral scientist embedded in a goal management app.

Your task is to convert the user's goal into a concrete, achievable, sustainable 6-week action plan.

You have access to:
- The user's daily schedule and availability (from the Scheduler)
- The user's behavioral patterns (from the Pattern Observer)
- Tags for this goal's category (from the Classifier)
- The user's existing active tasks

Principles you must follow:
1. SUSTAINABILITY: Never overload the user. Prefer fewer, consistent daily tasks over many sporadic ones.
2. INCREMENTALISM: Start easy. Ramp up difficulty gradually. Week 1 should feel almost too easy.
3. PATTERN AWARENESS: Avoid scheduling tasks at times the user has historically missed. Prefer times of high completion.
4. OVERLAP DETECTION: If an existing task already covers something this goal requires, note it and incorporate it rather than duplicating.
5. HONESTY: If there are not enough free slots to complete this goal in 6 weeks, say so clearly and suggest a start date.
6. NEGOTIATION: Always present the plan to the user before saving. Allow them to negotiate timing, frequency, or difficulty.

When generating tasks, output structured JSON:
{
  "goal_feasible_in_6_weeks": true | false,
  "micro_goal_roadmap": [...] | null,
  "proposed_tasks": [
    {
      "title": string,
      "description": string,
      "scheduled_days": ["Monday", "Wednesday", "Friday"],
      "suggested_time": "07:00",
      "duration_minutes": 30,
      "recurrence_rule": "RRULE:FREQ=WEEKLY;BYDAY=MO,WE,FR",
      "week_range": [1, 6]
    }
  ],
  "conflicts_detected": [...],
  "plan_summary": "A human-readable summary of the plan to present to the user"
}

After presenting the plan, continue the conversation to refine it. Only output SAVE_CONFIRMED when the user explicitly approves.
```

---

### 5.3 Classifier Agent

**Role:** Tags a goal with one or more category labels for analytics.

**LLM:** GPT-4o-mini (fast, structured output)

**Responsibilities:**
- Accept a goal statement and return a list of category tags.
- Tags are drawn from a fixed taxonomy (extensible).

**Taxonomy (v1):**
`Health`, `Fitness`, `Nutrition`, `Mental Health`, `Career`, `Learning`, `Financial`, `Relationships`, `Creativity`, `Productivity`, `Spirituality`, `Home`, `Travel`, `Other`

**System Prompt:**
```
You are a goal classifier. Given a user's goal statement, return a JSON array of 1‚Äì3 category tags from this exact list:
["Health", "Fitness", "Nutrition", "Mental Health", "Career", "Learning", "Financial", "Relationships", "Creativity", "Productivity", "Spirituality", "Home", "Travel", "Other"]

Rules:
- Never invent new tags.
- Prefer specific over general (e.g., "Fitness" over "Health" for exercise goals).
- Return ONLY valid JSON: { "tags": ["tag1", "tag2"] }
```

---

### 5.4 Scheduler Agent

**Role:** Manages the user's time. Finds available slots, detects conflicts, and writes confirmed plans to the database.

**LLM:** GPT-4o-mini (structured slot reasoning)

**Responsibilities:**
- Load the user's profile (sleep window, work hours) and existing tasks for the next 6 weeks.
- Given a set of task requirements (frequency, duration, preferred time-of-day), find valid time slots.
- Detect and surface conflicts with existing tasks.
- On plan confirmation from Goal Planner: write all tasks to the `tasks` table with correct `scheduled_at` timestamps and `recurrence_rule`.
- Handle slot negotiation: if a user requests a different time, re-check availability and confirm.

**Slot-Finding Logic:**
1. Load user's `profile.sleep_window` (e.g., 23:00‚Äì07:00) ‚Äî block these hours.
2. Load user's `profile.work_hours` (e.g., 09:00‚Äì18:00 Mon‚ÄìFri) ‚Äî treat as soft blocks (lower preference).
3. Load all existing `tasks` with `status IN ('pending', 'rescheduled')` for the next 6 weeks.
4. Build a free-slot matrix. For each task requirement, find the best matching slot using Pattern Observer hints.
5. Return candidate slots ranked by compatibility score.

**System Prompt:**
```
You are a scheduling assistant. You have access to the user's availability (their profile and existing tasks) and a set of task requirements from the Goal Planner.

Your job is to find the best available time slots for these tasks and return them as structured JSON.

Availability rules:
- Never schedule during sleep_window
- Prefer not to schedule during work_hours unless no other slots exist
- Never double-book existing tasks
- Apply a 15-minute buffer between tasks
- Prefer times with historically high completion rates (from Pattern Observer data)

Output format:
{
  "slots": [
    {
      "task_title": string,
      "scheduled_at": "ISO8601 datetime",
      "duration_minutes": int,
      "conflict": false
    }
  ],
  "conflicts": [...],
  "first_available_start": "ISO8601 date | null"
}
```

---

### 5.5 Pattern Observer Agent

**Role:** Learns from the user's behavioral history to improve scheduling recommendations.

**LLM:** GPT-4o-mini (pattern summarization)

**Signals tracked:**
- Task completion / miss history (by day of week, time of day)
- Category-level performance (e.g., user completes "Fitness" tasks at 80% but "Learning" tasks at 40%)

**Responsibilities:**
- **On consultation (by Goal Planner/Scheduler):** Summarize behavioral patterns as structured hints ‚Äî e.g., "User has a >80% completion rate for tasks before 09:00. User consistently misses tasks on Monday between 07:00‚Äì09:00 for the past 3 weeks."
- **On task miss signal:** Update patterns when a task is marked missed. If a task in the same time slot (¬±1 hour, same day of week) has been missed ‚â•3 times in 3 consecutive weeks, create/update a `patterns` record flagging this slot as avoidance.
- **Proactive surfacing (future v2):** Surface insights to the user: "I've noticed you skip gym sessions on Monday mornings. Want me to move those to Tuesday?"

**Cold-Start Strategy (new users with no history):**
- Use onboarding profile as the baseline ‚Äî e.g., if the user says they're a morning person, prefer 06:00‚Äì09:00 slots.
- Apply generic defaults: avoid Mondays for high-effort tasks (research-backed), prefer consistent daily times over varied ones.
- After 2 weeks of data, patterns become meaningful. Flag patterns as low-confidence until then.

**System Prompt:**
```
You are a behavioral pattern analyst. Given a user's task history (completions and misses), extract meaningful scheduling patterns.

Return a structured JSON summary:
{
  "best_times": ["07:00‚Äì09:00", "18:00‚Äì19:30"],
  "avoid_slots": [
    { "day": "Monday", "time_range": "07:00‚Äì09:00", "reason": "3 consecutive misses", "confidence": 0.85 }
  ],
  "category_performance": [
    { "category": "Fitness", "completion_rate": 0.78 },
    { "category": "Learning", "completion_rate": 0.42 }
  ],
  "general_notes": "User performs best on weekday mornings. Weekend engagement drops significantly."
}

Only report patterns with at least 3 data points. Mark low-confidence patterns (< 3 weeks of data) with confidence < 0.5.
```

---

### 5.6 Notifier Agent

**Role:** Background service that monitors task states and dispatches escalating notifications.

**LLM:** None. Pure deterministic state machine.

**Escalation Logic:**
```
T = scheduled_at

T - reminder_lead_minutes ‚Üí Send PUSH notification
  (default: 10 minutes before)

After push sent: poll every 30s for (escalation_window_minutes)
  (default: 2 minutes)

If task.status NOT IN ('done', 'missed') after escalation_window:
  ‚Üí Send WHATSAPP notification via Twilio

After WhatsApp sent: poll every 30s for (escalation_window_minutes)
If task.status NOT IN ('done', 'missed') after escalation_window:
  ‚Üí Initiate PHONE CALL via Twilio Programmable Voice

After call sent: poll every 30s for (escalation_window_minutes)
If task.status NOT IN ('done', 'missed') after escalation_window:
  ‚Üí Auto-set task.status = 'missed'
  ‚Üí Notify Pattern Observer (if 3rd consecutive miss in same slot)
```

**Twilio Call Script (TTS):**
```
"Hi! This is your assistant. [task_name] is coming up in the next [time_left_minutes] minutes.
Press 1 if you have already done it.
Press 2 if you want to reschedule.
Press 3 to mark it as missed."
```
DTMF responses map to: 1 ‚Üí `done`, 2 ‚Üí `reschedule` (opens chat), 3 ‚Üí `missed`.

**Reschedule from Notification:**
- Check if any slots are available in the remaining hours of the current day.
- If yes: show "Reschedule" option in WhatsApp/call. Deep link opens the chat with a pre-typed message: `"Reschedule task [task_id]: [task_name]"`.
- If no: hide "Reschedule" option.

**Location-Triggered Tasks (MVP ‚Äî Demo Mode):**
- Frontend exposes a toggle: "I'm away from home."
- Activating it triggers a POST to `/api/demo/location-trigger` ‚Üí backend queries all pending tasks with `trigger_type = 'location'` for this user ‚Üí sends reminder.
- Poll every 2 hours if trigger not acknowledged.

---

## 6. LangGraph Orchestration

### Graph Structure

```python
# Simplified node structure
graph = StateGraph(AgentState)

graph.add_node("orchestrator", orchestrator_node)
graph.add_node("clarify", clarify_node)          # Ask user for missing context
graph.add_node("goal_planner", goal_planner_node)
graph.add_node("classifier", classifier_node)
graph.add_node("scheduler", scheduler_node)
graph.add_node("pattern_observer", pattern_observer_node)
graph.add_node("save_tasks", save_tasks_node)     # Writes to Supabase
graph.add_node("task_handler", task_handler_node) # Handles standalone tasks

graph.set_entry_point("orchestrator")

graph.add_conditional_edges("orchestrator", route_from_orchestrator, {
    "GOAL": "goal_planner",
    "NEW_TASK": "task_handler",
    "RESCHEDULE_TASK": "scheduler",
    "CLARIFY": "clarify",
})

graph.add_edge("clarify", "orchestrator")  # Loop back after clarification

# Goal planning subgraph
graph.add_edge("goal_planner", "classifier")
graph.add_edge("goal_planner", "scheduler")
graph.add_edge("goal_planner", "pattern_observer")
# goal_planner collects all three, then negotiates

graph.add_conditional_edges("goal_planner", check_user_approval, {
    "APPROVED": "save_tasks",
    "NEGOTIATING": "goal_planner",  # Continue conversation
    "ABANDONED": END,
})

graph.add_edge("save_tasks", END)
graph.add_edge("task_handler", "save_tasks")
```

### State Schema

```python
class AgentState(TypedDict):
    user_id: str
    conversation_history: list[dict]  # Full message history
    intent: str
    user_profile: dict                # Cached from DB at session start
    goal_draft: dict | None
    proposed_tasks: list[dict] | None
    classifier_output: dict | None
    scheduler_output: dict | None
    pattern_output: dict | None
    approval_status: str | None       # 'pending' | 'approved' | 'negotiating'
    error: str | None
```

### Thread Persistence

- Each conversation session maps to a **LangGraph thread** identified by `langgraph_thread_id` stored in the `conversations` table.
- Thread state (full `AgentState`) is persisted in LangGraph's checkpoint store backed by Supabase (use `langgraph-checkpoint-postgres` or custom Supabase checkpointer).
- On session resume, load the thread and continue. Multi-turn goal negotiation can span multiple user sessions.

---

## 7. Notification Engine

### Architecture

The Notifier Agent runs as a **background service** separate from the FastAPI app, implemented with **APScheduler** (MVP) running within the same process, or **Celery + Redis** at scale.

```python
# Core polling loop (runs every 60 seconds)
@scheduler.scheduled_job('interval', seconds=60)
def notification_poll():
    now = datetime.utcnow()
    
    # Find tasks due for PUSH notification (T - 10min)
    due_for_push = db.query(tasks).filter(
        tasks.scheduled_at <= now + timedelta(minutes=10),
        tasks.scheduled_at > now,
        tasks.reminder_sent_at == None,
        tasks.status == 'pending'
    )
    for task in due_for_push:
        send_push(task)
        task.reminder_sent_at = now
    
    # Find tasks due for WhatsApp escalation
    due_for_whatsapp = db.query(tasks).filter(
        tasks.reminder_sent_at <= now - timedelta(minutes=ESCALATION_WINDOW),
        tasks.whatsapp_sent_at == None,
        tasks.status == 'pending'
    )
    ...
    
    # Find tasks due for call escalation
    # Find tasks to auto-mark missed
    # Find tasks to notify Pattern Observer
```

### Notification Channels

| Channel | Provider | Trigger | User Response |
|---|---|---|---|
| Push (web/PWA) | Supabase Realtime + Web Push API | T - 10min | In-app CTA buttons |
| WhatsApp | Twilio WhatsApp Business API | +2min after push (unacknowledged) | Reply with 1/2/3 or tap CTA |
| Phone Call | Twilio Programmable Voice (TTS) | +2min after WhatsApp (unacknowledged) | DTMF: 1/2/3 |
| Auto-miss | System | +2min after call (unacknowledged) | None |

### Webhook Endpoints

```
POST /api/webhooks/twilio/whatsapp  ‚Üí Handle WhatsApp replies
POST /api/webhooks/twilio/voice     ‚Üí Handle DTMF call responses
POST /api/tasks/{id}/complete       ‚Üí Handle in-app "Done" CTA
POST /api/tasks/{id}/missed         ‚Üí Handle in-app "Missed" CTA
POST /api/tasks/{id}/reschedule     ‚Üí Trigger reschedule chat flow
```

---

## 8. Analytics & Dashboard

### KPIs to Surface

| KPI | Visualization | Description |
|---|---|---|
| Goal Progress | Progress bar + % | Per-goal: tasks completed / total tasks |
| Weekly Completion % | Line chart | Rolling 12-week view of completion rate |
| Missed Tasks by Category | Bar chart | Which goal categories have most misses |
| Activity Heatmap | GitHub-style calendar heatmap | Daily task completion density over time |
| Streak Tracker | Flame icon + number | Consecutive days with ‚â•1 completed task |

### Data Aggregation

All analytics are computed from the `tasks` table. Use Supabase PostgreSQL views or materialized views for performance:

```sql
-- Weekly completion rate view
CREATE MATERIALIZED VIEW user_weekly_stats AS
SELECT
  user_id,
  DATE_TRUNC('week', scheduled_at) AS week,
  COUNT(*) FILTER (WHERE status = 'done') AS completed,
  COUNT(*) AS total,
  ROUND(COUNT(*) FILTER (WHERE status = 'done')::numeric / COUNT(*) * 100, 1) AS completion_pct
FROM tasks
GROUP BY user_id, week;

-- Missed by category view
CREATE MATERIALIZED VIEW missed_by_category AS
SELECT
  t.user_id,
  g.class_tags,
  COUNT(*) FILTER (WHERE t.status = 'missed') AS missed_count,
  COUNT(*) AS total_count
FROM tasks t
LEFT JOIN goals g ON t.goal_id = g.id
GROUP BY t.user_id, g.class_tags;
```

Refresh materialized views on a schedule (every hour) or trigger-based after task status updates.

---

## 9. UI/UX Flows

### Home Screen
- **Header:** Greeting + date
- **Today's Tasks:** Scrollable list of today's `pending` tasks, ordered by `scheduled_at`. Each card shows: task title, time, goal category tag (color-coded), and a "Mark Done" button.
- **Quick Stats:** Streak count, today's completion % (X of Y done)
- **FAB (Floating Action Button):** Opens chat ‚Äî the primary creation surface. Label: "Chat with your assistant"

### Chat Screen
- Full-height conversational UI (similar to iMessage/WhatsApp)
- User messages right-aligned, assistant left-aligned
- When the Goal Planner proposes a plan, it renders as a **structured card** within the chat (not raw text): shows task list with days/times, with "Accept Plan" and "Adjust Plan" buttons.
- Micro-goal roadmap is rendered as a vertical stepper card within the chat.

### Analytics Screen (Profile)
- Tabbed view: Overview ¬∑ Goals ¬∑ Patterns
- **Overview tab:** Streak, weekly completion line chart, activity heatmap
- **Goals tab:** Per-goal progress bars, category breakdown bar chart
- **Patterns tab (v2):** Surfaced behavioral insights from Pattern Observer

### Notification CTAs

**Push notification:**
> "üîî Gym session in 10 minutes!"
> [Already Done] [Reschedule] [Mark Missed]

**WhatsApp message:**
> "Hi! Your task **Gym session** is coming up. Please respond:
> 1Ô∏è‚É£ Already done
> 2Ô∏è‚É£ Reschedule
> 3Ô∏è‚É£ Mark as missed"

**Phone call (TTS):** See ¬ß5.6

---

## 10. Onboarding Flow

Onboarding is **done entirely via chat** ‚Äî the first conversation a new user has with the app. It runs once and is saved to `users.profile`. The Orchestrator detects `users.onboarded = false` and routes to an onboarding subgraph before normal operation begins.

### Questions Asked (in conversational order):

1. **Name** ‚Äî "What should I call you?"
2. **Wake time** ‚Äî "What time do you usually wake up?"
3. **Sleep time** ‚Äî "What time do you go to bed?"
4. **Work schedule** ‚Äî "Do you work during the day? If so, roughly what hours?"
5. **Morning person or night owl?** ‚Äî Used to weight preferred task times
6. **Home / Work location labels** (for future GPS; MVP collects as text for demo mode)
7. **Any existing regular commitments?** ‚Äî e.g., "I go to the gym on Tuesday evenings" ‚Üí pre-seeded as tasks
8. **First goal or task** ‚Äî "Great! Now, what's the first thing you'd like to work on?"

The final question transitions seamlessly into the normal goal/task flow.

**Profile JSON schema (`users.profile`):**
```json
{
  "name": "Alex",
  "sleep_window": { "start": "23:00", "end": "07:00" },
  "work_hours": { "start": "09:00", "end": "18:00", "days": ["Mon","Tue","Wed","Thu","Fri"] },
  "chronotype": "morning" | "evening" | "neutral",
  "existing_commitments": [
    { "title": "Gym", "days": ["Tuesday"], "time": "19:00", "duration_minutes": 60 }
  ],
  "locations": { "home": "labeled_home", "work": "labeled_work" }
}
```

---

## 11. API Design

All endpoints require JWT auth via Supabase Auth. Prefix: `/api/v1`

### Chat

```
POST   /chat/message          ‚Üí Send user message, get agent response (streams)
GET    /chat/history          ‚Üí Get conversation history for current session
```

### Goals

```
GET    /goals                 ‚Üí List user's goals (with status filter)
GET    /goals/{id}            ‚Üí Goal detail + pipeline
PATCH  /goals/{id}/abandon    ‚Üí Abandon goal; cancel all future tasks (not shared)
GET    /goals/{id}/tasks      ‚Üí All tasks for this goal
```

### Tasks

```
GET    /tasks/today           ‚Üí Today's tasks (for Home screen)
GET    /tasks/{id}            ‚Üí Task detail
PATCH  /tasks/{id}/complete   ‚Üí Mark done
PATCH  /tasks/{id}/missed     ‚Üí Mark missed
POST   /tasks/{id}/reschedule ‚Üí Trigger reschedule chat flow
```

### Analytics

```
GET    /analytics/overview         ‚Üí Streak, completion %, heatmap data
GET    /analytics/goals            ‚Üí Per-goal progress
GET    /analytics/missed-by-cat    ‚Üí Missed tasks by category
GET    /analytics/weekly           ‚Üí Weekly completion over 12 weeks
```

### Webhooks (Twilio)

```
POST   /webhooks/twilio/whatsapp   ‚Üí WhatsApp reply handler
POST   /webhooks/twilio/voice      ‚Üí DTMF voice response handler
```

### Demo Mode (MVP)

```
POST   /demo/trigger-location      ‚Üí Simulate "away from home" state
```

---

## 12. Privacy & Security Guardrails

- **Row Level Security (RLS)** enabled on all Supabase tables. Users can only read/write their own rows.
- **No PII in LLM prompts** beyond what the user explicitly shares in chat. User IDs, not names, are used in internal data payloads passed between agents.
- **Supabase Auth JWTs** are short-lived (1 hour) with refresh tokens. All API endpoints validate the JWT.
- **Twilio webhook validation** ‚Äî verify Twilio request signatures on all webhook endpoints.
- **Notification opt-in** ‚Äî WhatsApp and phone call notifications require explicit user opt-in during onboarding (phone number registration + double-opt-in for WhatsApp Business API compliance).
- **Data minimization** ‚Äî Pattern Observer only stores aggregated pattern summaries, not raw behavioral logs beyond what exists in the `tasks` table.
- **Onboarding data** stored in `users.profile` as JSONB ‚Äî encrypted at rest via Supabase (AES-256).
- **No third-party analytics SDKs** in MVP ‚Äî all analytics are computed from first-party data in Supabase.

---

## 13. Phase 2 Roadmap

| Feature | Notes |
|---|---|
| React Native app | Reuse FastAPI backend; replace PWA shell |
| Google Calendar integration | Bi-directional sync via Google Calendar API; Scheduler reads external events |
| GPS geofencing | React Native location APIs; replace Demo Mode |
| Pattern Observer UI | Users can view + correct learned patterns |
| "Already doing" flow | Detect existing habits via onboarding + task overlap |
| Streak notifications | "You're on a 7-day streak! Keep it up üî•" |
| Apple Calendar / Outlook | After Google Calendar |
| Collaborative goals | Shared goals between users (accountability partners) |
| Voice input | Whisper API for voice-to-text in chat |
| Widget (iOS/Android) | Today's tasks on home screen widget |

---

## 14. Open Decisions & Engineering Defaults

The following were not explicitly specified and have been given sensible defaults. Review before development begins.

| Decision | Default Applied | Revisit? |
|---|---|---|
| Reminder lead time | 10 minutes before task | Configurable per user in settings |
| Escalation window | 2 minutes between each channel | Configurable per user |
| Missed streak threshold | 3 consecutive misses in same slot ‚Üí Pattern Observer flagged | Hardcoded for MVP |
| Task duration estimate | AI estimates from task type; user can override | Locked unless negotiated |
| Max active goals | 3 simultaneous active goals | Prevents overload; configurable |
| Micro-goal chain trigger | Completing previous micro-goal (explicit mark done) | As specified |
| Pattern Observer cold start | Chronotype from onboarding + research-based defaults | Blends into real patterns after 2 weeks |
| LangGraph checkpoint store | `langgraph-checkpoint-postgres` on Supabase | Default; swap to Redis at scale |
| Analytics refresh | Materialized views refreshed every hour | Move to trigger-based at scale |
| Max goals in pipeline | No hard limit | Monitor DB growth |
| WhatsApp opt-in timing | During onboarding | Can be deferred to first escalation event |

---

*Document prepared for internal engineering use. All agent system prompts, data models, and API contracts are subject to revision during sprint planning.*